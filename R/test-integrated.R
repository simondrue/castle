#' @title Train integrated CASTLE model
#'
#' @description \code{train_integrated_ddpcr_model} estimates the parameters of
#'   the statistical model for the integrated version the CASTLE algorithm based
#'   on a set of training samples, assumed to have no mutant DNA present.
#'
#' @details In the test an integrated version of the Likelihood Ratio test
#'   statistic is used, and this is approximated using a Riemann sum on a
#'   3D-grid. The parameter \code{abc_grid_resolution} controls this
#'   approximation as the sum is calculated on \code{abc_grid_resolution^3}
#'   points. Higher values give better approximation but longer computational
#'   times.
#'
#' @param training_samples \code{data.frame} with cancer negative training
#'   samples as rows. At least the columns \code{N_WT_only}, \code{N_M_only},
#'   \code{N_d_neg} and \code{N_d_pos} should be present.
#' @param abc_grid_resolution The resolution of the 3D-grid on which the
#'   integrated LR-test statistic is approximated. Default is 25 (equal to a
#'   grid of 25^3 = 15,625 point).
#'
#' @return List of parameter estimates for the integrated CASLTE model. This
#'   should be used as input for \code{test_tumor_sample_integrated}.
#' @seealso \code{\link{test_tumor_sample_integrated}}
#' @export
train_integrated_ddpcr_model <- function(training_samples,
                                         abc_grid_resolution = 25) {
  # Check input
  check_input_samples(training_samples)

  # Unpack data
  N_WT_only_vec <- training_samples$N_WT_only
  N_M_only_vec <- training_samples$N_M_only
  N_d_neg_vec <- training_samples$N_d_neg
  N_d_pos_vec <- training_samples$N_d_pos

  # Train parameters (get MLE on training data)
  simple_model <- train_simple_ddpcr_model(
    training_samples = training_samples
  )

  # Get parameters from model
  l_est_vec <- simple_model$l_est_vec
  a_est <- simple_model$a_est
  b_est <- simple_model$b_est
  c_est <- simple_model$c_est

  # Get bounds of a, b and c to make a grid where training lik function has mass
  bounds <- find_abd_confidence_intervals(
    N_WT_only_vec = N_WT_only_vec,
    N_M_only_vec = N_M_only_vec,
    N_d_neg_vec = N_d_neg_vec,
    N_d_pos_vec = N_d_pos_vec,
    l_est_vec = l_est_vec,
    a_est = a_est,
    b_est = b_est,
    c_est = c_est,
    alpha = 1e-5
  )

  # Get symmetric buffer around estimate
  a_buffer <- max(a_est - bounds$a_CI_lower, bounds$a_CI_upper - a_est)
  b_buffer <- max(b_est - bounds$b_CI_lower, bounds$b_CI_upper - b_est)
  c_buffer <- max(c_est - bounds$c_CI_lower, bounds$c_CI_upper - c_est)

  # Get min and max values for error parameters
  a_min <- max(TOL_0, a_est - a_buffer)
  a_max <- a_est + a_buffer

  b_min <- max(TOL_0, b_est - b_buffer)
  b_max <- b_est + b_buffer

  c_min <- max(TOL_0, c_est - c_buffer)
  c_max <- c_est + c_buffer

  # Make intervals
  a_vec <- seq(from = a_min, to = a_max, length.out = abc_grid_resolution)
  b_vec <- seq(from = b_min, to = b_max, length.out = abc_grid_resolution)
  c_vec <- seq(from = c_min, to = c_max, length.out = abc_grid_resolution)

  # Grid of a, b and c
  abc_grid <- expand.grid(a_vec, b_vec, c_vec)

  # Get training log lik
  abc_grid_train_log_lik <- get_abc_grid_log_lik(
    N_WT_only_vec = N_WT_only_vec,
    N_M_only_vec = N_M_only_vec,
    N_d_neg_vec = N_d_neg_vec,
    N_d_pos_vec = N_d_pos_vec,
    l_vec = l_est_vec,
    abc_grid = abc_grid
  )

  # Gather results
  integrated_model <- list(
    a_est = a_est,
    b_est = b_est,
    c_est = c_est,
    l_est_vec = l_est_vec,
    abc_grid = abc_grid,
    abc_grid_train_log_lik = abc_grid_train_log_lik
  )

  return(integrated_model)
}

#' @title Test sample using integrated CASTLE model
#'
#' @description Tests samples for the presence of mutant DNA using the
#'   integrated version of the CASTLE algorithm.
#'
#' @param test_samples \code{data.frame} with samples to be tested  as rows. At
#'   least the columns \code{N_WT_only}, \code{N_M_only}, \code{N_d_neg} and
#'   \code{N_d_pos} should be present.
#' @param integrated_model A fitted model as generated by
#'   \code{train_integrated_ddpcr_model}.
#' @param include_r_CI logical. Should confidence intervals for \code{r} be
#'   included? Default is \code{TRUE}.
#' @param include_l_CI logical. Should confidence intervals for \code{l} be
#'   included? Default is \code{TRUE}.
#' @param alpha The alpha used for the statistical test and confidence
#'   intervals. Default is 0.05.
#'
#' @return A \code{data.frame} with results from the CASTLE algorithm (parameter
#'   estimates, CIs, p-values etc.) joined to the right of \code{test_samples}.
#'
#' @seealso \code{\link{train_integrated_ddpcr_model}}
#' @export
test_tumor_sample_integrated <- function(test_samples,
                                         integrated_model,
                                         alpha = 0.05,
                                         include_r_CI = TRUE,
                                         include_l_CI = TRUE) {
  # Check input
  check_input_samples(test_samples)

  # Test samples
  res_df <- NULL
  for (i in 1:nrow(test_samples)) {
    # Unpack input for sample i
    test_sample <- test_samples[i, ]

    # Data
    N_WT_only <- test_sample$N_WT_only
    N_M_only <- test_sample$N_M_only
    N_d_neg <- test_sample$N_d_neg
    N_d_pos <- test_sample$N_d_pos

    # Model parameters
    abc_grid <- integrated_model$abc_grid
    abc_grid_train_log_lik <- integrated_model$abc_grid_train_log_lik


    # Estimate l and r for test sample
    # Get starting value from simple method
    l_est <- estimate_l(
      N_WT_only = N_WT_only,
      N_M_only = N_M_only,
      N_d_neg = N_d_neg,
      N_d_pos = N_d_pos
    )

    r_est <- estimate_r_integrated(
      N_WT_only = N_WT_only,
      N_M_only = N_M_only,
      N_d_neg = N_d_neg,
      N_d_pos = N_d_pos,
      l_est = l_est, integrated_model = integrated_model
    )

    # Test hypothesis H0: r == 0 vs HA: r > 0
    # LLR with integrated likelihood function

    # Calculate LL for full model (HA)
    LL_A <- integrated_log_lik(
      l = l_est,
      r = r_est,
      N_WT_only = N_WT_only,
      N_M_only = N_M_only,
      N_d_neg = N_d_neg,
      N_d_pos = N_d_pos,
      abc_grid_train_log_lik = abc_grid_train_log_lik,
      abc_grid = abc_grid
    )

    # Calculate LL for simple model (H0)
    LL_0 <- integrated_log_lik(
      l = l_est,
      r = 0,
      N_WT_only = N_WT_only,
      N_M_only = N_M_only,
      N_d_neg = N_d_neg,
      N_d_pos = N_d_pos,
      abc_grid_train_log_lik = abc_grid_train_log_lik,
      abc_grid = abc_grid
    )

    # Get test statistic and p-value
    r_LLR_test_stat <- -2 * (LL_0 - LL_A)
    r_less_than_0_pval <- 1 - stats::pchisq(r_LLR_test_stat, 1)


    # Gather results
    total_droplets <- N_WT_only + N_M_only + N_d_neg + N_d_pos
    total_tumor_molecules_expected <- r_est * total_droplets
    is_tumor_positive <- r_less_than_0_pval < alpha

    # Collect results
    res <- list(
      # Estimated values for r
      r_est = r_est,
      # Estimated values for l:
      l_est = l_est,
      # Test statistics
      pval_r_leq_0 = r_less_than_0_pval,
      r_LLR_test_stat = r_LLR_test_stat,
      # Other results:
      is_tumor_positive = is_tumor_positive,
      total_tumor_molecules_expected = total_tumor_molecules_expected,
      total_droplets = total_droplets
    )

    if (include_r_CI) {
      # Find bounds on r
      bounds_res <- get_r_CI_integrated(
        r_est = r_est,
        l_est = l_est,
        N_WT_only = N_WT_only,
        N_M_only = N_M_only,
        N_d_neg = N_d_neg,
        N_d_pos = N_d_pos,
        alpha = alpha,
        abc_grid = abc_grid,
        abc_grid_train_log_lik = abc_grid_train_log_lik
      )

      # Extract bounds
      r_CI_lower <- bounds_res$r_CI_lower
      r_CI_upper <- bounds_res$r_CI_upper

      # Calculate CI on the number of "real" tumor molecules
      total_tumor_molecules_CI_lower <- r_CI_lower * total_droplets
      total_tumor_molecules_CI_upper <- r_CI_upper * total_droplets

      # Add CI's to results
      res <- append(res, list(
        # Estimated values for r
        r_CI_lower = r_CI_lower,
        r_CI_upper = r_CI_upper,
        # Total number of molecules
        total_tumor_molecules_CI_lower = total_tumor_molecules_CI_lower,
        total_tumor_molecules_CI_upper = total_tumor_molecules_CI_upper
      ))
    }

    if (include_l_CI) {
      # Find bounds on l
      # Model as binomial with p = P(WT=0)=exp(-l)
      WT_neg <- N_M_only + N_d_neg
      n_drops <- N_WT_only + N_M_only + N_d_neg + N_d_pos

      binom_res <- stats::binom.test(x = WT_neg, n = n_drops, conf.level = 1 - alpha)

      l_CI_lower <- -log(binom_res$conf.int[[2]])
      l_CI_upper <- -log(binom_res$conf.int[[1]])

      # Add CI's to results
      res <- append(res, list(
        # Estimated values for l:
        l_CI_lower = l_CI_lower,
        l_CI_upper = l_CI_upper
      ))
    }

    res_df <- dplyr::bind_rows(res_df, dplyr::bind_cols(test_sample, res))
  }

  return(res_df)
}
